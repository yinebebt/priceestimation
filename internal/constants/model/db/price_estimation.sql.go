// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: price_estimation.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addPriceEstimation = `-- name: AddPriceEstimation :one
INSERT INTO price_estimation (
                               product_name,
                               price,
                               user_id,
                               location_id
) VALUES ($1,$2,$3, $4) RETURNING id, product_name, user_id, price, location_id, created_at, updated_at
`

type AddPriceEstimationParams struct {
	ProductName string          `json:"product_name"`
	Price       decimal.Decimal `json:"price"`
	UserID      uuid.UUID       `json:"user_id"`
	LocationID  uuid.UUID       `json:"location_id"`
}

func (q *Queries) AddPriceEstimation(ctx context.Context, arg AddPriceEstimationParams) (PriceEstimation, error) {
	row := q.db.QueryRow(ctx, addPriceEstimation,
		arg.ProductName,
		arg.Price,
		arg.UserID,
		arg.LocationID,
	)
	var i PriceEstimation
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.UserID,
		&i.Price,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePriceEstimation = `-- name: DeletePriceEstimation :exec
DELETE FROM price_estimation
WHERE id = $1
`

func (q *Queries) DeletePriceEstimation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePriceEstimation, id)
	return err
}

const getPriceEstimation = `-- name: GetPriceEstimation :one
SELECT
    pe.id,
    pe.product_name,
    pe.price,
    pe.user_id,
    pe.location_id,
    pe.created_at,
    pe.updated_at,
    l.country AS location_country,
    l.region AS location_region,
    l.zone AS location_zone,
    l.city AS location_city
FROM price_estimation AS pe
         JOIN location AS l ON pe.location_id = l.id
WHERE pe.id = $1
    LIMIT 1
`

type GetPriceEstimationRow struct {
	ID              uuid.UUID       `json:"id"`
	ProductName     string          `json:"product_name"`
	Price           decimal.Decimal `json:"price"`
	UserID          uuid.UUID       `json:"user_id"`
	LocationID      uuid.UUID       `json:"location_id"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
	LocationCountry string          `json:"location_country"`
	LocationRegion  string          `json:"location_region"`
	LocationZone    string          `json:"location_zone"`
	LocationCity    string          `json:"location_city"`
}

func (q *Queries) GetPriceEstimation(ctx context.Context, id uuid.UUID) (GetPriceEstimationRow, error) {
	row := q.db.QueryRow(ctx, getPriceEstimation, id)
	var i GetPriceEstimationRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.Price,
		&i.UserID,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LocationCountry,
		&i.LocationRegion,
		&i.LocationZone,
		&i.LocationCity,
	)
	return i, err
}

const getPriceEstimations = `-- name: GetPriceEstimations :many
SELECT id, product_name, user_id, price, location_id, created_at, updated_at FROM price_estimation
ORDER BY created_at
`

func (q *Queries) GetPriceEstimations(ctx context.Context) ([]PriceEstimation, error) {
	rows, err := q.db.Query(ctx, getPriceEstimations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PriceEstimation{}
	for rows.Next() {
		var i PriceEstimation
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.UserID,
			&i.Price,
			&i.LocationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePriceEstimation = `-- name: UpdatePriceEstimation :one
UPDATE price_estimation
SET price = $1 WHERE id = $1 RETURNING id, product_name, user_id, price, location_id, created_at, updated_at
`

func (q *Queries) UpdatePriceEstimation(ctx context.Context, price decimal.Decimal) (PriceEstimation, error) {
	row := q.db.QueryRow(ctx, updatePriceEstimation, price)
	var i PriceEstimation
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.UserID,
		&i.Price,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
